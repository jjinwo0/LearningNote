# [ 디자인 패턴 ]

### "디자인패턴(Design Pattern) 이란?"
> 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용하여 해결할 수 있도록
> 하나의 **규약**

## 1. 싱글톤 패턴
> 하나의 클래스에 오직 하나의 인스턴스만을 가지는 패턴
> 
> 일반적으로 데이터베이스 연결 모듈에 많이 사용

### 1-A. 자바 싱글톤 패턴
```java
class Singleton{
    private static class SingleInstanceHolder{
        
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance(){
        
        return SingleInstanceHolder.INSTANCE;
    }
}

public class HelloWorld{
    public static void main(String[] args){

        Singleton a = Singleton.getInstance();
        Singleton b = Singleton.getInstance();
        
        if (a == b)
            System.out.println(true);
    }
}

/**
 * 결과값
 * true
 */
```

### 1-B 싱글톤 패턴의 장점&단점
- **[장점]**
  - 하나의 인스턴스를 공유하는 형태이므로 **인스턴스 생성 비용 감소**
- **[단점]**
  - 모듈 간 결합도를 강하게 만들어 **의존성이 높아짐**
  - TDD를 할 때 문제 발생
    - 단위 테스트를 할 때 테스트는 서로 독립적이어야 하며 어떤 순서로든 실행 가능해야 함
    - 하지만 하나의 인스턴스를 기반으로 하는 싱글톤 패턴은 **독립적인** 인스턴스를 만들기 힘듬

### 1-C 의존성 주입
- 모듈 간 결합도를 강하게 만드는 싱글톤 패턴의 단점 해소
- "A가 B에 의존성을 가진다" = "B가 변하면 A도 변해야 한다"
- 메인 모듈이 **'직접'** 하위모듈에게 의존성을 부여하는 것이 아닌, **의존성 주입자**가 중간에서 **'간접적'** 으로 의존성을 부여하는 방식
- **[장점]**
  - 결합도가 낮아짐으로써 모듈들을 쉽게 교체 가능하여 테스트가 쉽고 마이그레이션이 수월함
  - 추상화 레이어를 기반으로 구현체를 넣어주므로 애플리케이션 **의존성 방향이 일관**되고, **애플리케이션 추론이 쉬워**지고, **모듈 간 관계가 명확**해짐
- **[단점]**
  - 모듈 수 증가로 인해 복잡성 증가
  - 약간의 런타임 패널티 발생

### 1-D. 의존성 주입의 원칙
- **상위 모듈은 하위 모듈로부터 어떠한 것도 가져오면 안된다.**
- 상위/하위 모듈 모두 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하지 말아야 한다.

---

## 2. 팩토리 패턴
> 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
> 
> 상위클래스에서 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 내용을 구체화한다.

#### [팩토리 패턴의 장점]
- 상위 클래스와 하위 클래스의 분리에 의한 **느슨한 결합도**
- 상위 클래스에서는 인스턴스 생성 범위에 관여하지 않으므로 **유연성 증가**
- 객체 생성 로직이 구분되어있어 **유지보수성 증가**

### 2-A. 자바의 팩토리 패턴
```java
// 뼈대를 결정하는 상위 클래스
abstract class Coffee{
    
    public abstract int getPrice();
    
    public String toString(){
        return "Hi this coffee is " + this.getPrice();
    }
}

class CoffeeFactory{ // 객체 생성 역할을 담당하는 하위 클래스 (Factory)
    public static Coffee getCoffee(String type, int price){

        // 객체 생성 로직
        if ("Latte".equalsIgnoreCase(type))
            return new Latte(price);
        
        else if ("Americano".equalsIgnoreCase(type))
            return new Americano(price);

        else return new DefaultCoffee();
    }
}

class DefaultCoffee extends Coffee{
  private int price;

  public DefaultCoffee(){
    this.price = -1;
  }

  public int getPrice(){

    return this.price;
  }
}

class Latte extends Coffee{
  private int price;

  public Latte(int price){
    this.price = price;
  }

  public int getPrice(){

    return this.price;
  }
}

class Americano extends Coffee{
  private int price;

  public Americano(int price){
    this.price = price;
  }

  public int getPrice(){

    return this.price;
  }
}

puglic class HelloWorld{
    public static void main(String[] args){
      Coffee latte = CoffeeFactory.getCoffee("Latte", 5000);
      Coffee americano = CoffeeFactory.getCoffee("Americano", 2000);
      
      System.out.println("Factory latte :: " + latte);
      System.out.println("Factory americano :: " + americano);
    }
}
/**
 * 결과
 * Factory latte :: Hi this coffee is 5000
 * Factory americano :: Hi this coffee is 2000
 */
```