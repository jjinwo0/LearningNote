# [ 디자인 패턴 ]

### "디자인패턴(Design Pattern) 이란?"
> 프로그램을 설계할 때 발생했던 문제점들을 객체 간 상호 관계 등을 이용하여 해결할 수 있도록
> 하나의 **규약**

## 1. 싱글톤 패턴
> 하나의 클래스에 오직 하나의 인스턴스만을 가지는 패턴
> 
> 일반적으로 데이터베이스 연결 모듈에 많이 사용

### 1-A. 자바 싱글톤 패턴
```java
class Singleton{
    private static class SingleInstanceHolder{
        
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance(){
        
        return SingleInstanceHolder.INSTANCE;
    }
}

public class HelloWorld{
    public static void main(String[] args){

        Singleton a = Singleton.getInstance();
        Singleton b = Singleton.getInstance();
        
        if (a == b)
            System.out.println(true);
    }
}

/**
 * 결과값
 * true
 */
```

### 1-B 싱글톤 패턴의 장점&단점
- **[장점]**
  - 하나의 인스턴스를 공유하는 형태이므로 **인스턴스 생성 비용 감소**
- **[단점]**
  - 모듈 간 결합도를 강하게 만들어 **의존성이 높아짐**
  - TDD를 할 때 문제 발생
    - 단위 테스트를 할 때 테스트는 서로 독립적이어야 하며 어떤 순서로든 실행 가능해야 함
    - 하지만 하나의 인스턴스를 기반으로 하는 싱글톤 패턴은 **독립적인** 인스턴스를 만들기 힘듬

### 1-C 의존성 주입
- 모듈 간 결합도를 강하게 만드는 싱글톤 패턴의 단점 해소
- "A가 B에 의존성을 가진다" = "B가 변하면 A도 변해야 한다"
- 메인 모듈이 **'직접'** 하위모듈에게 의존성을 부여하는 것이 아닌, **의존성 주입자**가 중간에서 **'간접적'** 으로 의존성을 부여하는 방식
- **[장점]**
  - 결합도가 낮아짐으로써 모듈들을 쉽게 교체 가능하여 테스트가 쉽고 마이그레이션이 수월함
  - 추상화 레이어를 기반으로 구현체를 넣어주므로 애플리케이션 **의존성 방향이 일관**되고, **애플리케이션 추론이 쉬워**지고, **모듈 간 관계가 명확**해짐
- **[단점]**
  - 모듈 수 증가로 인해 복잡성 증가
  - 약간의 런타임 패널티 발생

### 1-D. 의존성 주입의 원칙
- **상위 모듈은 하위 모듈로부터 어떠한 것도 가져오면 안된다.**
- 상위/하위 모듈 모두 추상화에 의존해야 한다.
- 추상화는 세부사항에 의존하지 말아야 한다.

---

## 2. 팩토리 패턴
> 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
> 
> 상위클래스에서 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 내용을 구체화한다.

#### [팩토리 패턴의 장점]
- 상위 클래스와 하위 클래스의 분리에 의한 **느슨한 결합도**
- 상위 클래스에서는 인스턴스 생성 범위에 관여하지 않으므로 **유연성 증가**
- 객체 생성 로직이 구분되어있어 **유지보수성 증가**

### 2-A. 자바의 팩토리 패턴
```java
// 뼈대를 결정하는 상위 클래스
abstract class Coffee{
    
    public abstract int getPrice();
    
    public String toString(){
        return "Hi this coffee is " + this.getPrice();
    }
}

class CoffeeFactory{ // 객체 생성 역할을 담당하는 하위 클래스 (Factory)
    public static Coffee getCoffee(String type, int price){

        // 객체 생성 로직
        if ("Latte".equalsIgnoreCase(type))
            return new Latte(price);
        
        else if ("Americano".equalsIgnoreCase(type))
            return new Americano(price);

        else return new DefaultCoffee();
    }
}

class DefaultCoffee extends Coffee{
  private int price;

  public DefaultCoffee(){
    this.price = -1;
  }

  public int getPrice(){

    return this.price;
  }
}

class Latte extends Coffee{
  private int price;

  public Latte(int price){
    this.price = price;
  }

  public int getPrice(){

    return this.price;
  }
}

class Americano extends Coffee{
  private int price;

  public Americano(int price){
    this.price = price;
  }

  public int getPrice(){

    return this.price;
  }
}

public class HelloWorld{
    public static void main(String[] args){
      Coffee latte = CoffeeFactory.getCoffee("Latte", 5000);
      Coffee americano = CoffeeFactory.getCoffee("Americano", 2000);
      
      System.out.println("Factory latte :: " + latte);
      System.out.println("Factory americano :: " + americano);
    }
}
/**
 * 결과
 * Factory latte :: Hi this coffee is 5000
 * Factory americano :: Hi this coffee is 2000
 */
```
---

## 3. 전략패턴

> **'정책 패턴(policy pattern)'** 이라고도 함
> 
> 객체의 행위를 바꾸고 싶을 때 **직접** 수정하지 않고 전략이라고 부르는 **'캡슐화한 알고리즘'** 을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

### 3-A. 자바의 전략 패턴
```java
interface PaymentStrategy{
    
    public void pay(int amount);
}

// 전략 1 : KAKAO
class KAKAOCardStrategy implements PaymentStrategy{

  private String name;
  private String cardNumber;
  private String cvv;
  private String dateOfExpiry;

  public KAKAOCardStrategy(String rm, String ccNum, String cvv, String expiryDate){

    this.name = rm;
    this.cardNumber = ccNum;
    this.cvv = ctt;
    this.dateOfExpiry = expiryDate;
  }

  public void pay(int amount){
    System.out.println(amount + " paid using KAKAOCard");
  }
}

// 전략 2 : LUNA
class LUNACardStrategy implements PaymentStrategy{
    
    private String emailId;
    private String password;

  public LunaCardStrategy(String email, String pwd){
      
      this.emailId = email;
      this.password = pwd;
  }
  
  public void pay(int amount){
    System.out.println(amount + " paid using LUNACard");
  }
}

class Item{
    private String name;
    private int price;
    
    public Item(String name, int cost){
        
        this.name = name;
        this.price = cost;
    }
    
    public String getName(){
        return name;
    }
    
    public int getPrice(){
        return price;
    }
}

class ShoppingCart{
    
    List<Item> items;
    
    public ShoppingCart(){
        this.items = new ArrayList<Item>();
    }
    
    public void addItem(Item item){
        this.items.add(item);
    }
    
    public void removeItem(Item item){
        this.items.remove(item);
    }
    
    public int calculateTotal(){
        return this.items.size();
    }
    
    public void pay(PaymentStrategy paymentMethod){
        
        int amount = calculateTotal();
        paymentMethod.pay(amount);
    }
}

public class HelloWorld{
    public static void main(String[] args){
        
        ShoppingCart cart = new ShoppingCart();
        
        Item A = new Item("kundo1A", 100);
        Item B = new Item("kundo1B", 300);

        cart.addItem(A);
        cart.addItem(B);

        // pay by LUNA
        cart.pay(new LUNACardStrategy("kundo1A@exam.com", "pukubababo"));
  
        // pay by KAKAO
        cart.pay(new KAKAOCardStrategy("kundo1B", "1234", "123", "12/01"));
    }
}

/**
 * 결과
 * 400 paid using LUNACard
 * 400 paid using KAKAOCard
 */
```
