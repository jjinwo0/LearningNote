## #1-1. 의미를 알 수 없는 이름

### [code 1-1] 기술 중심 명명

```java
class MemoryStateManager{
	void changeIntValue01(int changeValue){
		intValue01 -= changeValue;

		if(intValue01 < 0){
			intValue01 = 0;
			updateState02Flag();
		}
	}
}
```

> 기술을 기반으로 이름 붙이는 것을 **‘기술 중심 명명’**이라고 한다. (Memory, flag, …)
>

### [code 1-2] 일련번호 명명

```java
class Class001{
	void method001();
	void method002();
	void method003();
}
```

> 클래스와 메서드에 번호를 붙어 이름 짓는 것을 **‘일련번호 명명’**이라고 한다.
>

이와 같이 기술을 기반으로 이름짓거나, 일련번호를 매겨 이름을 지으면 **코드를 통해 어떠한 의도도 읽어낼 수 없다.**

이렇게 이름을 지은 코드는 이해하기 어려우며, 읽고 이해하는데 시간이 오래걸리게 된다.

또한, 충분히 이해하지 못한 상태로 코드를 변경하면 버그가 발생할 가능성이 크다.

이러한 위험을 줄이고자 메서드의 역할과 기능을 설명을 위한 문서를 만들기도 하지만, 현업에서는 바쁜 업무로 인해 유지보수가 거의 이루어지지 않습니다.

코드는 계속해서 변경되지만 문서의 유지보수가 이를 따라가지 못한다면, 결국 문서가 거짓말을 하게 되는 꼴이며 이는 버그가 더 쉽게 발생하게 되는 결과를 초래하게 됩니다.

## #1-2. 이해하기 어렵게 만드는 조건 분기 중첩

조건 분기는 조건에 따라 처리 방식을 다르게 하는 데 사용되는 구조입니다.

이러한 조건 분기는 어설프게 사용하게 된다면, 악마가 되어 개발자를 괴롭힙니다.

### [code 1-3] 여러 번 중첩된 로직

```java
// 게임에서 마법 발동의 조건을 구현한 예시
// 살아있는지 판정
if(0 < member.hitPoint){
	//움직일 수 있는지 판정
	if(memer.canAct()){
		//매직 포인트에 여유가 있는지 판정
		if(magic.costMagicPoint <= member.magicPoint){
			member.consumeMagicPoint(magic.costMagicPoint);
			member.chant(magic);
		}
	}
}
```

게임에서 어떠한 멤버에게 마법을 쓰라고 지시했을 때, 마법을 사용할 수 있는 상황인지에 대해 확인해야 할 조건이 많습니다.

따라서 위의 예시처럼 마법 발동 가능 상태인지 여러 번 판정해야 합니다.

위와 같이 if 조건 안에 if 조건, 그리고 또 그 안에 if 조건이 있는 상태를 **if 조건문이 중첩되어있다** 라고 표현합니다.

중첩은 많으면 많을수록 코드의 가독성이 나빠집니다. 어디서부터 어디까지가 if 조건 처리블록인지 알기 힘들어지기 때문입니다.

## #1-3. 수많은 악마를 만들어 내는 데이터 클래스

데이터 클래스는 단순한 구조를 가지지만, 수많은 악마를 만들어 낼 수 있습니다.

### [code 1-5] 데티어밖에 없는 클래스 구조

```java
// 업무 계약을 다루는 서비스의 데이터 클래스
public class ContractAmount{
	public int amountIncludingTax; // 세금 포함 금액
	public BicDecimal salesTaxRate; // 소비세율
}
```

각 변수를 public 인스턴스 변수로 갖고 있으므로, 클래스 밖에서도 데이터를 자유롭게 변경할 수 있는 구조입니다.

이처럼 데이터를 갖고있기만 하는 클래스를 **데이터 클래스**라고 부릅니다.

하지만 해당 데이터 클래스에는 세금이 포함된 금액을 계산하는 로직도 필요한데, 이러한 계산 로직을 데이터 클래스가 아닌 다른 클래스에 구현하는 일이 벌어지곤 합니다.